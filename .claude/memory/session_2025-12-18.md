# Session Memory: 2025-12-18

## Work Completed

### T-04: MinIO Storage Wrapper (Completed)
- Created `app/storage/` package with object storage abstraction
- Files created:
  - `app/storage/__init__.py` - Package exports
  - `app/storage/contracts.py` - ObjectStorage, Presigner protocols + StorageError
  - `app/storage/minio_impl.py` - MinioStorage implementation
  - `app/storage/factory.py` - build_storage() factory with bucket auto-creation
  - `app/deps.py` - Lazy get_storage() singleton
  - `tests/test_storage_minio.py` - 9 tests, 100% coverage

- Fixed along the way:
  - Session utility tests for SQLAlchemy 2.x compatibility (monkeypatch instead of SessionLocal.configure)
  - Added missing object_key field to test fixtures

### T-05: PDF Parsing Module (Completed)
- Created pure function PDF parser for Temporal Activity compatibility
- Files created:
  - `app/pdf_parser.py` - Pure function parser with:
    - `PDFError`, `PDFValidationError`, `PDFParseError` error hierarchy
    - `ParseResult` frozen dataclass
    - `extract_text_and_pages(data, max_size_mb, max_pages)` function
  - `tests/test_pdf_parser.py` - 20 tests, 100% coverage

- Config additions to `app/core/config.py`:
  - `PDF_MAX_FILE_SIZE_MB: int = 25`
  - `PDF_MAX_PAGES: int = 100`

- Architecture decisions:
  - Pure function pattern (bytes in → ParseResult out) for Temporal replay safety
  - Two-tier error hierarchy: ValidationError (final fail) vs ParseError (retryable)
  - Early validation before expensive parsing
  - Scanned PDF detection (no text → reject)

- Discoveries:
  - pdfplumber.PDF doesn't have `is_encrypted` - encrypted PDFs fail at open/extract
  - Used existing contract PDFs as test fixtures

## EXECPLAN Documents Updated
- `.agent/docs/EXECPLAN_T04.md` - Marked complete with retrospective
- `.agent/docs/EXECPLAN_T05.md` - Created proper architecture plan, marked complete

## Next Steps (Ready for T-07)
The PDF parser integrates with Temporal Activity like this:
```python
@activity.defn
async def parse_pdf(document_id: str) -> dict:
    storage = get_storage()
    data, _ = storage.get_bytes("uploads", f"{document_id}.pdf")
    result = extract_text_and_pages(data, max_size_mb=settings.PDF_MAX_FILE_SIZE_MB)
    return {"text": result.text, "page_count": result.page_count}
```

## Test Status
- All tests pass (including storage and PDF parser)
- Storage package: 100% coverage
- PDF parser: 100% coverage
- Overall project coverage: ~47% (pre-existing issue, not these tasks)
